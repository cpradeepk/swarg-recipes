
'use server'; // Mark this module as server-only

import type { Recipe, User, Ingredient, RecipeStep, NutritionalInfo } from "@/types";
import pool from './db'; // Import the database pool
import { RowDataPacket, OkPacket } from 'mysql2';

// Helper to generate unique IDs (simple version for mock data)
// For DB, primary keys are usually auto-increment or UUIDs generated by DB or application layer.
// We'll use this for client-side generation before DB insertion if needed, or rely on DB.
// The schema uses VARCHAR(36) for IDs, so UUIDs are appropriate.
import { randomUUID } from 'crypto'; // Node.js built-in crypto module for UUIDs

const generateId = (prefix: string = ''): string => {
  const uuid = randomUUID();
  return prefix ? `${prefix}-${uuid}` : uuid;
}


// --- User Functions ---
// mockUsers is no longer the source of truth for login.
// Users will be fetched from the database.
// This array can be removed or kept for seeding/testing if desired.
const mockUsers: User[] = [
  { id: "a1b2c3d4-e5f6-7890-1234-567890abcdef", email: "user@example.com", name: "John Doe", avatarUrl: "https://placehold.co/100x100.png", aiHint: "man portrait", is_admin: false },
  { id: "b2c3d4e5-f6a7-8901-2345-67890abcdef0", email: "admin@swargfood.com", name: "Admin Alice", avatarUrl: "https://placehold.co/100x100.png", aiHint: "woman portrait", is_admin: true },
  { id: "c3d4e5f6-a7b8-9012-3456-7890abcdef01", email: "pradeep@swargfood.com", name: "Pradeep Admin", avatarUrl: "https://placehold.co/100x100.png", aiHint: "man portrait", is_admin: true },
];

export const getUserByEmail = async (email: string): Promise<User | null> => {
  const [rows] = await pool.query<RowDataPacket[]>('SELECT id, email, name, avatar_url, ai_hint, is_admin FROM users WHERE email = ?', [email]);
  if (rows.length === 0) {
    return null;
  }
  const dbUser = rows[0];
  return {
    id: dbUser.id,
    email: dbUser.email,
    name: dbUser.name,
    avatarUrl: dbUser.avatar_url,
    aiHint: dbUser.ai_hint,
    is_admin: !!dbUser.is_admin, // Ensure boolean
  };
};


// --- Recipe Functions ---

// Helper function to map database row to Recipe type
const mapDbRowToRecipe = (row: RowDataPacket): Omit<Recipe, 'ingredients' | 'steps'> => ({
  id: row.id,
  name: row.name,
  category: row.category,
  description: row.description,
  imageUrl: row.image_url,
  aiHint: row.ai_hint,
  visibility: !!row.visibility,
  prepTime: row.prep_time,
  cookTime: row.cook_time,
  totalTime: row.total_time,
  servings: row.servings,
  nutritionalInfoPerServing: {
    calories: row.nutritional_calories,
    protein: row.nutritional_protein,
    fat: row.nutritional_fat,
    carbs: row.nutritional_carbs,
  },
  createdAt: row.created_at,
  updatedAt: row.updated_at,
});

export const getRecipes = async (): Promise<Recipe[]> => {
  const [recipeRows] = await pool.query<RowDataPacket[]>(`
    SELECT * FROM recipes WHERE visibility = TRUE ORDER BY created_at DESC
  `);
  
  // For the main recipe list, we might not need full ingredients/steps to keep it performant.
  // Or, fetch them if RecipeCard needs more details. For now, returning without.
  return recipeRows.map(row => ({
      ...mapDbRowToRecipe(row),
      ingredients: [], // Populate if needed for cards, or on recipe detail page
      steps: [],       // Populate if needed for cards, or on recipe detail page
  }));
};

export const getAllRecipesForAdmin = async (): Promise<Recipe[]> => {
   const [recipeRows] = await pool.query<RowDataPacket[]>(`
    SELECT * FROM recipes ORDER BY created_at DESC
  `);
  return recipeRows.map(row => ({
      ...mapDbRowToRecipe(row),
      ingredients: [], 
      steps: [],       
  }));
}

export const getRecipeById = async (id: string): Promise<Recipe | undefined> => {
  const [recipeRows] = await pool.query<RowDataPacket[]>('SELECT * FROM recipes WHERE id = ?', [id]);
  if (recipeRows.length === 0) {
    return undefined;
  }
  const recipeData = mapDbRowToRecipe(recipeRows[0]);

  const [ingredientRows] = await pool.query<RowDataPacket[]>('SELECT * FROM ingredients WHERE recipe_id = ? ORDER BY item_order ASC', [id]);
  const ingredients: Ingredient[] = ingredientRows.map(row => ({
    id: row.id,
    name: row.name,
    quantity: row.quantity,
    unit: row.unit,
    imageUrl: row.image_url,
    aiHint: row.ai_hint,
    item_order: row.item_order,
  }));

  const [stepRows] = await pool.query<RowDataPacket[]>('SELECT * FROM recipe_steps WHERE recipe_id = ? ORDER BY step_number ASC', [id]);
  const steps: RecipeStep[] = stepRows.map(row => ({
    id: row.id,
    stepNumber: row.step_number,
    instruction: row.instruction,
    imageUrl: row.image_url,
    aiHint: row.ai_hint,
    timerInSeconds: row.timer_in_seconds,
    temperature: row.temperature,
  }));

  return {
    ...recipeData,
    ingredients,
    steps,
  };
};

export const addRecipe = async (recipeData: Omit<Recipe, 'id' | 'createdAt' | 'updatedAt'>): Promise<Recipe> => {
  const connection = await pool.getConnection();
  try {
    await connection.beginTransaction();

    const recipeId = generateId();
    const recipeDbData = {
      id: recipeId,
      name: recipeData.name,
      category: recipeData.category,
      description: recipeData.description,
      image_url: recipeData.imageUrl,
      ai_hint: recipeData.aiHint,
      visibility: recipeData.visibility,
      prep_time: recipeData.prepTime,
      cook_time: recipeData.cookTime,
      total_time: recipeData.totalTime,
      servings: recipeData.servings,
      nutritional_calories: recipeData.nutritionalInfoPerServing?.calories,
      nutritional_protein: recipeData.nutritionalInfoPerServing?.protein,
      nutritional_fat: recipeData.nutritionalInfoPerServing?.fat,
      nutritional_carbs: recipeData.nutritionalInfoPerServing?.carbs,
      created_at: new Date(),
      updated_at: new Date(),
    };

    await connection.query('INSERT INTO recipes SET ?', recipeDbData);

    for (const ing of recipeData.ingredients) {
      const ingredientId = generateId();
      await connection.query('INSERT INTO ingredients SET ?', {
        id: ingredientId,
        recipe_id: recipeId,
        name: ing.name,
        quantity: ing.quantity,
        unit: ing.unit,
        image_url: ing.imageUrl,
        ai_hint: ing.aiHint,
        item_order: ing.item_order || 0, // Ensure item_order is set
      });
    }

    for (const step of recipeData.steps) {
      const stepId = generateId();
      await connection.query('INSERT INTO recipe_steps SET ?', {
        id: stepId,
        recipe_id: recipeId,
        step_number: step.stepNumber,
        instruction: step.instruction,
        image_url: step.imageUrl,
        ai_hint: step.aiHint,
        timer_in_seconds: step.timerInSeconds,
        temperature: step.temperature,
      });
    }

    await connection.commit();

    // Fetch the newly created recipe to return it in full
    const newRecipe = await getRecipeById(recipeId);
    if (!newRecipe) throw new Error('Failed to fetch newly created recipe');
    return newRecipe;

  } catch (error) {
    await connection.rollback();
    console.error('Error adding recipe to DB:', error);
    throw error; // Re-throw to be caught by the action
  } finally {
    connection.release();
  }
};

// Placeholder for updateRecipe - to be implemented later
export const updateRecipe = async (recipeId: string, updatedData: Partial<Omit<Recipe, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Recipe | null> => {
  console.warn("updateRecipe is not fully implemented for database yet.");
  // This would involve updating the 'recipes' table, and potentially deleting/re-inserting ingredients and steps,
  // or updating them individually if they have stable IDs and you implement that logic.
  // For a full implementation, careful handling of transactions is needed.
  const connection = await pool.getConnection();
  try {
    await connection.beginTransaction();

    const recipePayload: any = { ...updatedData };
    delete recipePayload.ingredients;
    delete recipePayload.steps;
    delete recipePayload.nutritionalInfoPerServing; // Handle separately

    if (updatedData.nutritionalInfoPerServing) {
      recipePayload.nutritional_calories = updatedData.nutritionalInfoPerServing.calories;
      recipePayload.nutritional_protein = updatedData.nutritionalInfoPerServing.protein;
      recipePayload.nutritional_fat = updatedData.nutritionalInfoPerServing.fat;
      recipePayload.nutritional_carbs = updatedData.nutritionalInfoPerServing.carbs;
    }
    
    recipePayload.image_url = updatedData.imageUrl;
    recipePayload.prep_time = updatedData.prepTime;
    recipePayload.cook_time = updatedData.cookTime;
    recipePayload.total_time = updatedData.totalTime;


    if (Object.keys(recipePayload).length > 0) {
         await connection.query('UPDATE recipes SET ?, updated_at = NOW() WHERE id = ?', [recipePayload, recipeId]);
    }


    // Ingredients and steps update logic:
    // Option 1: Delete all existing and re-insert (simpler for full updates)
    // Option 2: Diff and update/insert/delete (more complex)
    if (updatedData.ingredients) {
        await connection.query('DELETE FROM ingredients WHERE recipe_id = ?', [recipeId]);
        for (const [index, ing] of updatedData.ingredients.entries()) {
            const ingredientId = ing.id || generateId(); // Reuse ID if provided, else generate
             await connection.query('INSERT INTO ingredients SET ?', {
                id: ingredientId,
                recipe_id: recipeId,
                name: ing.name,
                quantity: ing.quantity,
                unit: ing.unit,
                image_url: ing.imageUrl,
                ai_hint: ing.aiHint,
                item_order: index,
            });
        }
    }

    if (updatedData.steps) {
        await connection.query('DELETE FROM recipe_steps WHERE recipe_id = ?', [recipeId]);
        for (const step of updatedData.steps) {
            const stepId = step.id || generateId(); // Reuse ID if provided
            await connection.query('INSERT INTO recipe_steps SET ?', {
                id: stepId,
                recipe_id: recipeId,
                step_number: step.stepNumber,
                instruction: step.instruction,
                image_url: step.imageUrl,
                ai_hint: step.aiHint,
                timer_in_seconds: step.timerInSeconds,
                temperature: step.temperature,
            });
        }
    }
    
    await connection.commit();
    return getRecipeById(recipeId).then(r => r || null);

  } catch (error) {
      await connection.rollback();
      console.error(`Error updating recipe ${recipeId}:`, error);
      return null;
  } finally {
      connection.release();
  }
};


export const deleteRecipe = async (recipeId: string): Promise<boolean> => {
  const connection = await pool.getConnection();
  try {
    await connection.beginTransaction();
    // Cascading delete should handle ingredients and steps if FKs are set up correctly
    const [result] = await connection.query<OkPacket>('DELETE FROM recipes WHERE id = ?', [recipeId]);
    await connection.commit();
    return result.affectedRows > 0;
  } catch (error) {
    await connection.rollback();
    console.error(`Error deleting recipe ${recipeId}:`, error);
    return false;
  } finally {
    connection.release();
  }
};

export const toggleRecipeVisibility = async (recipeId: string, visibility: boolean): Promise<Recipe | null> => {
  const [result] = await pool.query<OkPacket>('UPDATE recipes SET visibility = ?, updated_at = NOW() WHERE id = ?', [visibility, recipeId]);
  if (result.affectedRows > 0) {
    const updatedRecipe = await getRecipeById(recipeId);
    return updatedRecipe || null;
  }
  return null;
};

